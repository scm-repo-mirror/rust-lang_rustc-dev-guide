<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Implementing new language features - Rust Compiler Development Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A guide to developing the Rust compiler (rustc)">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="pagetoc.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Compiler Development Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide/edit/main/src/implementing_new_features.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- date-check: Jul 2025 -->
<h1 id="implementing-new-language-features"><a class="header" href="#implementing-new-language-features">Implementing new language features</a></h1>
<p>When you want to implement a new significant feature in the compiler,
you need to go through this process to make sure everything goes smoothly.</p>
<p><strong>NOTE: This section is for <em>language</em> features, not <em>library</em> features,
which use <a href="./stability.html">a different process</a>.</strong></p>
<p>See also <a href="https://lang-team.rust-lang.org/how_to/propose.html">the Rust Language Design Team's procedures</a> for proposing changes to the language.</p>
<h2 id="the-rfcbot-fcp-process"><a class="header" href="#the-rfcbot-fcp-process">The @rfcbot FCP process</a></h2>
<p>When the change is small, uncontroversial, non-breaking,
and does not affect the stable language in any user-observable ways or add any new unstable features,
then it can be done with just writing a PR and getting an r+ from someone who knows that part of the code.
However, if not, more must be done.
Even for compiler-internal work,
it would be a bad idea to push a controversial change without consensus from the rest of the team
(both in the "distributed system" sense to make sure you don't break anything you don't know about,
and in the social sense to avoid PR fights).</p>
<p>For changes that need the consensus of a team,
we use the process of proposing a final comment period (FCP).
If you're not on the relevant team (and thus don't have @rfcbot permissions),
ask someone who is to start one;
unless they have a concern themselves, they should.</p>
<p>The FCP process is only needed if you need consensus –
if no processes require consensus for your change
and you don't think anyone would have a problem with it, it's OK to rely on only an r+.
For example,
it is OK to add or modify unstable command-line flags
or attributes in the reserved compiler-internal <code>rustc_</code> namespace
without an FCP for compiler development or standard library use,
as long as you don't expect them to be in wide use in the nightly ecosystem.
Some teams have lighter weight processes that they use in scenarios like this;
for example,
the compiler team recommends filing a Major Change Proposal (<a href="https://forge.rust-lang.org/compiler/proposals-and-stabilization.html#how-do-i-submit-an-mcp">MCP</a>)
as a lightweight way to garner support and feedback without requiring full consensus.</p>
<p>You don't need to have the implementation fully ready for r+ to propose an FCP,
but it is generally a good idea to have at least a proof of concept
so that people can see what you are talking about.</p>
<p>When an FCP is proposed, it requires all members of the team to sign off on the FCP.
After they all do so,
there's a 10-day-long "final comment period" (hence the name) where everybody can comment,
and if no concerns are raised, the PR/issue gets FCP approval.</p>
<h2 id="the-logistics-of-writing-features"><a class="header" href="#the-logistics-of-writing-features">The logistics of writing features</a></h2>
<p>There are a few "logistical" hoops you might need to go through
in order to implement a feature in a working way.</p>
<h3 id="warning-cycles"><a class="header" href="#warning-cycles">Warning Cycles</a></h3>
<p>In some cases, a feature or bugfix might break some existing programs in some edge cases.
In that case,
you'll want to do a crater run to assess the impact and possibly add a future-compatibility lint,
similar to those used for <a href="diagnostics.html#edition-gated-lints">edition-gated lints</a>.</p>
<h3 id="stability"><a class="header" href="#stability">Stability</a></h3>
<p>We <a href="https://github.com/rust-lang/rfcs/blob/master/text/1122-language-semver.md">value the stability of Rust</a>.
Code that works and runs on stable should (mostly) not break.
Because of that,
we don't want to release a feature to the world with only team consensus and code review -
we want to gain real-world experience on using that feature on nightly,
and we might want to change the feature based on that experience.</p>
<p>To allow for that,
we must make sure users don't accidentally depend on that new feature -
otherwise,
especially if experimentation takes time or is delayed and the feature takes the trains to stable,
it would end up de facto stable
and we'll not be able to make changes in it without breaking people's code.</p>
<p>The way we do that is that we make sure all new features are feature gated -
they can't be used without enabling a feature gate (<code>#[feature(foo)]</code>),
which can't be done in a stable/beta compiler.
See the <a href="#stability-in-code">stability in code</a> section for the technical details.</p>
<p>Eventually, after we gain enough experience using the feature, make the necessary changes,
and are satisfied, we expose it to the world using the stabilization process described <a href="./stabilization_guide.html">here</a>.
Until then, the feature is not set in stone:
every part of the feature can be changed, or the feature might be completely rewritten or removed.
Features do not gain tenure by being unstable and unchanged for long periods of time.</p>
<h3 id="tracking-issues"><a class="header" href="#tracking-issues">Tracking Issues</a></h3>
<p>To keep track of the status of an unstable feature,
the experience we get while using it on nightly,
and of the concerns that block its stabilization,
every feature-gate needs a tracking issue.
When creating issues and PRs related to the feature, reference this tracking issue,
and when there are updates about the feature's progress, post those to the tracking issue.</p>
<p>For features that are part of an accept RFC or approved lang experiment,
use the tracking issue for that.</p>
<p>For other features, create a tracking issue for that feature.
The issue title should be "Tracking issue for YOUR FEATURE".
Use the <a href="https://github.com/rust-lang/rust/issues/new?template=tracking_issue.md">"Tracking Issue" issue template</a>.</p>
<h3 id="lang-experiments"><a class="header" href="#lang-experiments">Lang experiments</a></h3>
<p>To land in the compiler,
features that have user-visible effects on the language (even unstable ones)
must either be part of an accepted RFC or an approved <a href="https://lang-team.rust-lang.org/how_to/experiment.html">lang experiment</a>.</p>
<p>To propose a new lang experiment,
open an issue in <code>rust-lang/rust</code> that describes the motivation and the intended solution.
If it's accepted, this issue will become the tracking issue for the experiment,
so use the tracking issue <a href="https://github.com/rust-lang/rust/issues/new?template=tracking_issue.md">template</a> while also including these other details.
Nominate the issue for the lang team and CC <code>@rust-lang/lang</code> and <code>@rust-lang/lang-advisors</code>.
When the experiment is approved, the tracking issue will be marked as <code>B-experimental</code>.</p>
<p>Feature flags related to a lang experiment must be marked as <code>incomplete</code>
until an RFC is accepted for the feature.</p>
<h2 id="stability-in-code"><a class="header" href="#stability-in-code">Stability in code</a></h2>
<p>The below steps needs to be followed in order to implement a new unstable feature:</p>
<ol>
<li>
<p>Open or identify the <a href="#tracking-issues">tracking issue</a>.
For features that are part of an accept RFC or approved lang experiment,
use the tracking issue for that.</p>
<p>Label the tracking issue with <code>C-tracking-issue</code> and the relevant <code>F-feature_name</code> label
(adding that label if needed).</p>
</li>
<li>
<p>Pick a name for the feature gate (for RFCs, use the name in the RFC).</p>
</li>
<li>
<p>Add the feature name to <code>rustc_span/src/symbol.rs</code> in the <code>Symbols {...}</code> block.</p>
<p>Note that this block must be in alphabetical order.</p>
</li>
<li>
<p>Add a feature gate declaration to <code>rustc_feature/src/unstable.rs</code>
in the unstable <code>declare_features</code> block.</p>
<pre><code class="language-rust ignore">/// description of feature
(unstable, $feature_name, "CURRENT_RUSTC_VERSION", Some($tracking_issue_number))</code></pre>
<p>If you haven't yet opened a tracking issue
(e.g. because you want initial feedback on whether the feature is likely to be accepted),
you can temporarily use <code>None</code> - but make sure to update it before the PR is merged!</p>
<p>For example:</p>
<pre><code class="language-rust ignore">/// Allows defining identifiers beyond ASCII.
(unstable, non_ascii_idents, "CURRENT_RUSTC_VERSION", Some(55467), None),</code></pre>
<p>Features can be marked as incomplete,
and trigger the warn-by-default <a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#incomplete-features"><code>incomplete_features</code> lint</a>
by setting their type to <code>incomplete</code>:</p>
<pre><code class="language-rust ignore">/// Allows deref patterns.
(incomplete, deref_patterns, "CURRENT_RUSTC_VERSION", Some(87121), None),</code></pre>
<p>Feature flags related to a lang experiment must be marked as <code>incomplete</code>
until an RFC is accepted for the feature.</p>
<p>To avoid <a href="https://bors.tech/essay/2017/02/02/pitch/">semantic merge conflicts</a>,
use <code>CURRENT_RUSTC_VERSION</code> instead of <code>1.70</code> or another explicit version number.</p>
</li>
<li>
<p>Prevent usage of the new feature unless the feature gate is set.
You can check it in most places in the compiler
using the expression <code>tcx.features().$feature_name()</code>.</p>
<p>If the feature gate is not set,
you should either maintain the pre-feature behavior or raise an error,
depending on what makes sense.
Errors should generally use <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/parse/fn.feature_err.html"><code>rustc_session::parse::feature_err</code></a>.
For an example of adding an error, see <a href="https://github.com/rust-lang/rust/pull/81015">#81015</a>.</p>
<p>For features introducing new syntax, pre-expansion gating should be used instead.
During parsing, when the new syntax is parsed,
the symbol must be inserted to the current crate's <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/parse/struct.GatedSpans.html"><code>GatedSpans</code></a>
via <code>self.sess.gated_span.gate(sym::my_feature, span)</code>.</p>
<p>After being inserted to the gated spans,
the span must be checked in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast_passes/feature_gate/fn.check_crate.html"><code>rustc_ast_passes::feature_gate::check_crate</code></a> function,
which actually denies features.
Exactly how it is gated depends on the exact type of feature,
but most likely will use the <code>gate_all!()</code> macro.</p>
</li>
<li>
<p>Add a test to ensure the feature cannot be used without a feature gate,
by creating <code>tests/ui/feature-gates/feature-gate-$feature_name.rs</code>.
You can generate the corresponding <code>.stderr</code> file
by running <code>./x test tests/ui/feature-gates/ --bless</code>.</p>
</li>
<li>
<p>Add a section to the unstable book,
in <code>src/doc/unstable-book/src/language-features/$feature_name.md</code>.</p>
</li>
<li>
<p>Write a lot of tests for the new feature, preferably in <code>tests/ui/$feature_name/</code>.
PRs without tests will not be accepted!</p>
</li>
<li>
<p>Get your PR reviewed and land it.
You have now successfully implemented a feature in Rust!</p>
</li>
</ol>
<h2 id="call-for-testing"><a class="header" href="#call-for-testing">Call for testing</a></h2>
<p>Once the implementation is complete,
the feature will be available to nightly users but not yet part of stable Rust.
This is a good time to write a blog post on <a href="https://github.com/rust-lang/blog.rust-lang.org/">the main Rust blog</a>
and issue a "call for testing".</p>
<p>Some earlier such blog posts include:</p>
<ol>
<li><a href="https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push/">The push for GATs stabilization</a></li>
<li><a href="https://blog.rust-lang.org/2024/09/05/impl-trait-capture-rules.html">Changes to <code>impl Trait</code> in Rust 2024</a></li>
<li><a href="https://blog.rust-lang.org/inside-rust/2024/08/09/async-closures-call-for-testing/">Async Closures MVP: Call for Testing!</a></li>
</ol>
<p>Alternatively, <a href="https://github.com/rust-lang/this-week-in-rust"><em>This Week in Rust</em></a> has a <a href="https://this-week-in-rust.org/blog/2025/01/22/this-week-in-rust-583/#calls-for-testing">section</a> for this.
One example of this having been used is:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/131204#issuecomment-2569314526">Call for testing on boolean literals as cfg predicates</a></li>
</ul>
<p>Which option to choose might depend on how significant the language change is,
though note that the <a href="https://github.com/rust-lang/this-week-in-rust"><em>This Week in Rust</em></a> section might be less visible
than a dedicated post on the main Rust blog.</p>
<h2 id="polishing"><a class="header" href="#polishing">Polishing</a></h2>
<p>Giving users a polished experience means more than just implementing the feature in rustc.
We need to think about all of the tools and resources that we ship.
This work includes:</p>
<ul>
<li>Documenting the language feature in the <a href="https://github.com/rust-lang/reference">Rust Reference</a>.</li>
<li>Extending <a href="https://github.com/rust-lang/rustfmt"><code>rustfmt</code></a> to format any new syntax (if applicable).</li>
<li>Extending <a href="https://github.com/rust-lang/rust-analyzer"><code>rust-analyzer</code></a> (if applicable).
The extent of this work can depend on the nature of the language feature,
as some features don't need to be blocked on <em>full</em> support.
<ul>
<li>When a language feature degrades the user experience
simply by existing before support is implemented in <a href="https://github.com/rust-lang/rust-analyzer"><code>rust-analyzer</code></a>,
that may lead the lang team to raise a blocking concern.</li>
<li>Examples of such might include new syntax that <a href="https://github.com/rust-lang/rust-analyzer"><code>rust-analyzer</code></a> can't parse
or type inference changes it doesn't understand when those lead to bogus diagnostics.</li>
</ul>
</li>
</ul>
<h2 id="stabilization"><a class="header" href="#stabilization">Stabilization</a></h2>
<p>The final step in the feature lifecycle is <a href="./stabilization_guide.html">stabilization</a>,
which is when the feature becomes available to all Rust users.
At this point,
backward incompatible changes are generally no longer permitted
(see the lang team's <a href="https://rust-lang.github.io/rfcs/1122-language-semver.html">defined semver policies</a> for details).
To learn more about stabilization, see the <a href="./stabilization_guide.html">stabilization guide</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="walkthrough.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="stability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="walkthrough.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="stability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="pagetoc.js"></script>



    </div>
    </body>
</html>
